(ns leiningen.cljsbuild-dalap
  (:require [clojure [string :as string]
                     [pprint :refer [pprint]]
                     ]
            ;;[clojure.tools.namespace :refer [find-clojure-sources-in-dir]]
            [clojure.java.io :refer [as-file]]
            [robert.hooke]
            [dalap [walk :refer [walk]]
                   [selector :refer [-gen-decorator]]]
            [leiningen.cljsbuild]
            [cljsbuild-dalap.transform-rules :refer
             [cljs-default-transform-rules]])
  (:import [clojure.lang LineNumberingPushbackReader]
           [java.io File])
  )


;;;; Old dalap.clojure walk

(defn visit-clj-form [form w]
  ;; a modified version of clojure.walk with the ability to drop forms
  (letfn [(filter-map [f form] (remove #(= % ::drop) (map f form)))]
    (cond
      (list? form) (apply list (filter-map w form))
      (instance? clojure.lang.IMapEntry form) (vec (filter-map w form))
      (seq? form) (doall (filter-map w form))
      (coll? form) (into (empty form) (filter-map w form))
      :else form)))

(defn clj-forms-to-cljs-forms
  ([forms]
     (clj-forms-to-cljs-forms forms cljs-default-transform-rules))
  ([forms rules]
     (walk forms ((-gen-decorator rules) visit-clj-form))))

(defn read-forms-from-file
  ;; see https://github.com/jonase/kibit/blob/master/src/kibit/check.clj
  "Gen a lazy sequence of top level forms from a LineNumberingPushbackReader"
  [^LineNumberingPushbackReader r]
  (lazy-seq
   (let [form
         (try
           (read r false ::eof)
           (catch Exception e
             (throw (Exception.
                     (str "Dalap's reader crashed"
                          (.getMessage e)) e))))]
     (when-not (= form ::eof)
       (cons form (read-forms-from-file r))))))

(defn read-clj-forms-from-input [input]
  (read-forms-from-file
   (LineNumberingPushbackReader.
    ;; IMPORTANT:
    ;; this piece of code replaces _top level_ #_(:cljs)
    ;; forms with a (do) so that forms inside it get executed
    ;; only in clojurescript
    ;; e.g:
    ;; #_(:cljs (println "hello world")) => (do (println "hello world"))
    (java.io.StringReader.
     (string/replace (slurp input) #"\#_\(\s*:cljs\b" "(do ")))))

(defn cljs-generated-file-notice [clj-file-path]
  (str ";;This file autogenerated from \n;;\n;; " clj-file-path
       " @ " (java.util.Date.)
       "\n;;\n"))

(defn transform-to-cljs-file
  ([input transform-rules]
     (let [;;input-file (as-file input)
           ;;path (.getPath f)
           ;; rules (if (or (fn? transform-rules)
           ;;               (map? transform-rules))
           ;;         (transform-rules path)
           ;;         transform-rules)
           cljs-forms (clj-forms-to-cljs-forms
                         (read-clj-forms-from-input input) transform-rules)]
       (str ;;(cljs-generated-file-notice path)
            (cljs-generated-file-notice input)
            (string/join "\n" cljs-forms)))))


;;;;

(defn run-compiler [run-compiler-
                    {:keys [transform-files] :as project}
                    {:keys [builds] :as opts}
                    build-ids watch?]

  ;; (println "HEY JO! you are about to compile the source code")
  ;; (println "=====")
  ;; (pprint opts)
  ;; (println "=====")
  ;; (pprint build-ids)
  ;; (println "=====")
  ;; (pprint watch?)
  ;; (println "=====")
  ;;(pprint (mapcat (comp find-clojure-sources-in-dir :source-path) builds))
  (doseq [[input-file output-file] transform-files]
    (println "transforming" input-file "to cljs")
    (spit output-file (transform-to-cljs-file input-file
                                              cljs-default-transform-rules)))
  (run-compiler- project opts build-ids watch?))

(defn activate []
  (robert.hooke/add-hook #'leiningen.cljsbuild/run-compiler #'run-compiler))

 (defn cljsbuild-dalap
   "I don't do a lot."
   [project & args]
   (println "Hi!"))